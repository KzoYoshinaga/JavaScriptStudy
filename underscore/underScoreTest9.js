$(function(){
	// p189 ７章 純粋性、不変性、変更ポリシー
	
	// 完全に関数型かつ実用的なスタイルを求めるための要点を説明する
	// 関数を使って構築すること、だけではなく
	// 関数型プログラミングは、ソフトウェアの創造プロセスにまとわりつく複雑さを最小限に抑えるための構築方法を考える手段
	// 複雑さを抑える方法のひとつはプログラム内の状態変更を最小限に抑える、
	// もしくは(理想的には)完全に排除すること
	
	
	//******************************************************************************************
	// p189 7.1 純粋性 *************************************************************************
	
	// ある数値を与えられると１からその数値までの間から(擬似)ランダムに選んだ数値を返すような関数を考える
	var rand = partial1(_.random, 1);
	
	log("rand(10)", rand(10)); // => 8
	
	var result = repeatedly(10, partial1(rand, 10));
	log("repeat10 rand", result); // => [6,10,1,10,4,4,3,2,2,6]

	var result = _.take(repeatedly(100, partial1(rand, 10)), 5);
	log("take5 repaet10 rand", result); // => [6,3,5,9,4]
	
	// ランダムな小文字アルファベットと数字で構成された文字列を生成する関数のパーツとしても使える
	function randString(len) {
		var ascii =  repeatedly(len, partial1(rand, 36));
		return _.map(ascii, function(n) {
			return n.toString(36);}).join('');
	}
	
	log("randString(0)", randString(0)); // => ""
	log("randString(1)", randString(1)); // => "h"
	log("randString(10)", randString(10)); // => "gxhw4iriw2"
	
	// この関数はこれまでの関数とは大きな違いを一つ持っている
	// その違いが見えるか？
	
	// この答えはもう一つの質問の答えの一部
	//「あなたはこれをテストできますか？」
	
	//******************************************************************************************
	// p190 7.1.1 純粋性とテストの関係
	
	// 純粋性のルール
	// ・結果は引数として与えられた値からのみ計算される
	// ・関数の外部で変更される可能性のあるデータに一切依存しない
	// ・関数実行部の外側に存在する何かの状態を一切変更しない
	
	// randString関数は計算使用するための引数を取らない
	// _.randomに依存している
	
	// 呼び出し時に「シード値」の提供を許容することで、ランダム数値の生成を行う純粋関数を書くことができる
	
	// １つ目のルールを破る他の例
	PI = 3.14;
	function areaOfACircle(radius) {
		return PI * radius * radius;
	}
	log("areaOfACircle(3)", areaOfACircle(3));
	
	//******************************************************************************************
	// p193 7.2 純粋と不純を分離する ***********************************************************
	
	// そもそもJavaScriptのMath.randメソッドは純粋関数ではないため、このメソッドを使用するすべての関数は
	// 純粋ではなくなり、多くの場合はテストがより複雑になる
	
	// 純粋な関数は、入力値とそれに対応する予測出力値のテーブルデータを作成してテストします
	
	// 完全な純粋性を持つことは出来ないが純粋な部分と不純な部分に分離して、変更の影響を最小化できる
	
	// 不純な部分
	function generateRandomCharacter() {
		return rand(26).toString(36); // 意図的に誤りを仕込んでいる
	}
	
	// 純粋な部分
	function generateString(charGen, len) {
		return repeatedly(len, charGen).join('');
	}
	
	// 関数合成により不純な文字列生成関数を組み立てることができる
	var generateRandomString = partial1(generateString, generateRandomCharacter);
	log("generateRandomString(10)", generateRandomString(10)); // => "ccjog746gd"
	
	// 純粋な部分だけ単独でテストすることができる
	
	// 考察 : ランダムな数字を文字列に変換するのではなく
	//        設定したドメインから選ぶためのインデックスを生成する
	//        ドメインの正当性、生成されたインデックスの正当性の検証で済むのでは？
	
	
	//******************************************************************************************
	// p195 7.2.1 不純関数を適切にテストする
	
	// 不純な部分を最小限まで絞り込んで隔離した場合、テストはいくぶんか楽になる
	// 戻り値が特定の値である場合をテストすることは出来ませんが戻り値の一定の特徴についてはテストできる
	
	// generateRondomCharacterでの戻り値の特徴
	// ・ASCII文字であること
	// ・１桁の数値であること
	// ・文字列型であること
	// ・文字であること
	// ・小文字であること
	
	// 大量のテストデータが必要になる、反復回数を増やしても完全に満足できない
	// 生成される文字が一定の範囲内の文字列であることを確認することもいい
	// generateRandomCharacterの実装には(意図的な誤りによる)すべての小文字を生成できない
	// と言う制限がある
	
	//******************************************************************************************
	// p196 7.2.2 純粋性と参照透過性との関係
	
	// JavaScriptの型付けに対する緩さによる問題が発生することがある
	log("true + 1 === 2", true + 1 === 2); // => true
	// 記述されたコードが及ぼす影響が把握しにくくなり、テストがより難しくなる
	
	// 純粋関数を使う場合は、関数の合成が簡単に行え、コード内の関数を同等の関数または
	// 予想される値で置き換えることができるようになる
	// e.g.
	function nth(array, index) {
		return array[index];
	}
	// 参照透過性(transparency) : 引数が同じであればいつ実行されても同じ値を返す
	
	// 与えられた引数を変更しない
	
	// しかしnth関数は不純なもの、オブジェクトや配列、もしくは不純関数を返す可能性がある
	
	// この問題を修正するためには純粋関数だけを定義および使用するように気をつけることだけ
	
	//******************************************************************************************
	// p199 7.2.3 純粋性と冪等性の関係
	
	// 冪等性(idempotence) : あるアクションを何度行ってもい一度行った場合と全く同じ効果をもたらす
	
	// 冪等である関数は次の条件を満たす
	// someFun(arg) == _.compose(someFun, someFun)(arg);
	
	var a = [1, [10, 20, 30], 3];
	var secondTwice = _.compose(second, second);
	log("second(a) === secondTwice(a)", second(a) === secondTwice(a));
	// => false
	
	var dissociativeIdentity = _.compose(_.identity, _.identity);
	log("_.identity(42) === _.dissociativeIdentity(42)", _.identity(42) === dissociativeIdentity(42));
	// => true
	
	log("Math.abs(-42) === Math.abs(Mas.abs(-42))", Math.abs(-42) === Math.abs(Math.abs(-42)));
	// => true
	
	//******************************************************************************************
	// p200 7.3 不変性 *************************************************************************
	
	// 文字列型は不変性を持った数少ないデータ型
	
	// JavaScriptにおいて次のような変異は許容されている
	var obj = {lemongrab: "Earl"};
	
	(function(o){
		_.extend(o, {lemongrab: "King"});
		})(obj);
	
	log("obj['lemongrab']", obj['lemongrab']); // "King"
	
	// _.extend(destination, *sorces) sourcesに渡されたオブジェクトのプロパティをdestinationオブジェクト
	// に追加する。その際、destinationオブジェクト自身が変更対象となり、キーが重複する場合は新しい値で
	// 上書きされる。sorcesに渡した順番に上書きするため、最後に渡されたオブジェクトが優先される
	
	//******************************************************************************************
	// p203 7.3.1 誰もいない森で木が倒れたら、音がするでしょうか？
	
	// 数値 n と配列を渡すと、配列のインデックスが n の倍数の要素を抜き出して新たな配列に格納し
	// その新たな配列を返します
	function skipTake(n, coll) {
		var ret = [];
		
		var sz = _.size(coll);
		for(var index = 0; index < sz; index += n){
			ret.push(coll[index]);
		}
		return ret;
	}
	
	log("skipTake(2, [1,2,3,45,6])", skipTake(2, [1,2,3,45,6])); // => [1, 3, 6]
	log("skipTake(4, _.range(20))", skipTake(4, _.range(20))); // => [0, 4, 8, 12, 16]
	
	// 配列を変異させるArray#pushの実行を含んだ命令型スタイルのループを意図的に使用
	// 関数型プログラミングのテクニックを使ってskipTakeを実装する方法もある
	// しかし、forループを使った実装は小さく単純で、早く動作する。
	// そして、ここで重要なのは、命令型アプローチを使っている事実が、この関数の使用者に
	// 完全に隠蔽されているということ
	
	// 関数を抽象の基本的なユニットとしてみる利点は、その実装内容さえ「漏れる」ことがなければ
	// 関数内部の詳細な実装方法はまったく無関係であるということ
	
	// 誰もいない森で木が倒れたら、音がするでしょうか？
	// 不変性を持った戻り値を生成するために純粋関数がローカルデータを変異させたとしたら
	// それは良いことなのでしょうか？
	// -----Rich Hickey
	
	//******************************************************************************************
	// p204 7.3.2 不変性と、その再帰との関係
	
	// 多くの関数型プログラミング言語では、ローカル変数の変異を用いたsummのような関数を書くことができない
	function summ(array) {
		var result = 0;
		var sz = array.length;
		
		for(var i = 0; i < sz; i ++) result += array[i];
		
		return result;
	}
	
	log("summ(_.range(1,11))", summ(_.range(1,11)) ); // => 55
	
	// 関数summの問題は、 i と result と言う２つのローカル変数を変異させているということ
	// 伝統的な関数型言語におけるローカル変数は実際には全く「変数」ではなく、不変であり、変更することができない。
	
	// このようなローカル変数を変更するためのただ一つの方法は、コールスタックを介して変更すること
	// つまり、これは再帰が行うことそのものである。サブファンクションの引数で渡すことで関数外からの変更が加わる
	function summRec(array, seed) {
		if(_.isEmpty(array))
			return seed;
		else
			return summRec(_.rest(array), _.first(array) + seed);
	}
	
	log("summRec([],0)", summRec([],0)); // => 0
	log("summRec(_.range(1,11),0)", summRec(_.range(1,11), 0)); // => 55
	
	// JavaScriptはこのような再帰を使った状態管理を許容しますが、同時にローカル変数の変異も許容する
	// 早く動くのであればそちらを使った方がよい
	
	//******************************************************************************************
	// p206 7.3.3 防御的フリーズとクローン
	
	// 最近のJavaScriptにはオブジェクトもしくは配列が渡された場合に、その後のすべての変更を無効にする
	// Object#freezというメソッドが提供されている
	
	// Strict mode でJavaScriptを記述している場合は変更が無効にされた時点でTypeError例外をスローし
	// Strict mode ではない場合は失敗したことを知らせることなく失敗します
	
	var a = [1, 2, 3];
	a[1] = 42;
	log("a a[1] <= 42", a); // => [1, 42, 3]
	
	Object.freeze(a);
	
	a[1] = 108;
	log("freezed a a[1] <= 108", a); // => [1, 42, 3] // 変更は反映されていない
	
	log("Object.isFrozen(a)", Object.isFrozen(a)); // => true
	
	// Object#freezeを使用した不変性の確保には２つの問題がある
	// ・コードベース全体をコントロールできる立場にいないと。微妙なエラーを発生させる可能性がある
	// ・Object#freezeは「浅く」フリーズさせる
	
	// Object#freezeはオブジェクトの一番上のレベルのみフリーズさせ、ネストされたオブジェクトはフリーズしない
	
	var x = [{a: [1, 2, 3], b: 42}, {c: {d: []}}];
	Object.freeze(x);
	x[0] == "";
	log("shallowFrozen x[0]['a']", x[0]['a']); // => [1, 2, 3]  // 一段目の変更は反映されていない
	
	x[1]['c']['d'] = 10000;
	log("shallowFrozeen x[1]['c']['d']", x[1]['c']['d']); // 10000 // 二段目以降の変更は反映されている
	
	
	// 「深い」フリーズを行う場合は、再帰を使ってデータ構造を探索する必要がある
	function deepFreeze(obj) {
		if(!Object.isFrozen(obj))
			Object.freeze(obj);
		
		for(var key in obj) {
			if(!obj.hasOwnProperty(key) || !_.isObject(obj[key]))
				continue;
				
		deepFreeze(obj[key]);
		}
	}
	
	var x = [{a: [1, 2, 3], b: 42}, {c: {d: []}}];
	
	deepFreeze(x);
	x[0] = null;
	log("deepFrozen x[0]['a']", x[0]['a']); // => [1, 2, 3]  // 変更は反映されていない
	
	x[1]['c']['d'] = 10000;
	log("deepFrozeen x[1]['c']['d']", x[1]['c']['d']); // => "" // 二段目以降も変更が反映されていない
	
	// しかしオブジェクトをフリーズすることは、サードパーティAPIを使用する場合にバグをもたらす可能性がある
	// 外見ではフリーズされているかどうか分からない
	
	// 不変性を保つために取りうる手段は実質的に以下の３点のいずれか
	// ・浅いコピーで十分である場合は、_.cloneを使ってコピーする
	// ・深いコピーが必要な場合はdeepCloneを使う
	// ・純粋関数を使ってコードを記述する
	
	// 本書では３つ目のオプションを使う
	// 関数型及びオブジェクト中心APIの純粋性のために、不変性を保つという考え方進めていく
	
	//******************************************************************************************
	// p209 7.3.4 関数レベルでの不変性を意識する
	
	// コレクションを引数にとり、コレクションを構築する
	
	// e.g. 数値または文字列の配列を引数にとり、配列のそれぞれの要素のキーに、
	//      要素が配列に登場した回数をフィールドの値としたオブジェクトを返す関数を考える
	var freq = curry2(_.countBy)(_.identity);
	
	// _.countBy関数の動作は非破壊的であるため、_.identityと組み合わせると純粋関数を作ることが出来る
	var a = repeatedly(1000, partial1(rand, 2));
	var copy = _.clone(a);
	log("freq(a)", freq(a)); // => {1: 501, 2: 499}
	log("_.isEqual(a, copy)", _.isEqual(a, copy)); // => true
	
	// 関数内に可変変数を持っているがskipTake関数も純粋であるため、安全に合成できる
	log("freq(skipTake(2, a))",freq(skipTake(2, a))); // => {1: 245, 2: 255}
	log("_.isEqual(a, copy)", _.isEqual(a, copy)); // => true
	
	// オブジェクトの内容を変更してしまう関数
	var person = {fname: "Simon"};
	var result = _.extend(person, {lname: "Petrikov"}, {age: 28}, {age: 108});
	log("_.extend result", result); // => {fname: "Simon", lname: "Petrikov", age: 108}
	log("modified person", person); // => {fname: "Simon", lname: "Petrikov", age: 108}
	// _.extendは一つ目に与えられた引数を左から右に結合していく
	
	// _.extendを使ってオブジェクトを結合する新たな関数mergeを変わりに定義する
	function merge(/* 任意の数のオブジェクト */) {
		return _.extend.apply(null, construct({}, arguments));
	}
	
	var person = {fname: "Simon"};
	var result = merge(person, {lname: "Petrikov"}, {age: 28}, {age: 108});
	log("merge result", result); // => {fname: "Simon", lname: "Petrikov", age: 108}
	log("person", person); // => {fname: "Simon"} // もとのオブジェクトは変更されない
	
	//******************************************************************************************
	// p211 7.3.5 オブジェクトの不変性を観察する
	
	// 不変性を浸透させるために敷くべき規律の例
	// e.g. Pointオブジェクトを断片的に実装する
	
	function Point(x, y) {
		this._x = x;
		this._y = y;
	}
	
	// Pointオブジェクトのインスタンスは外部からアクセスできるフィールドを持っていない
	// という事実を隠蔽するために、クロージャによるカプセル化の技法に頼ることになる
	var p = new Point(1,2);
	log("p['_x']", p['_x']); // => 1 // 参照できてしまう
	
	// しかし著者は「プライベートな」フィールドに特別な名前を与えるようなコンストラクタを定義するという
	// シンプルなアプローチを好む(この場合は_を付与)
	
	// 不変性を保つというポリシーに従いつつ、withXとwithYという２つの「変更」メソッドを実装する
	
	// ここではconstructorプロパティを除外する、本来であればPoint.prototypeはconstructorプロパティを持つ
	
	Point.prototype = {
		withX: function(val) {
			return new Point(val, this._y);
		},
		withY: function(val) {
			return new Point(this._x, val);
		}
	};
	
	// これらの変更オブジェクトは実際には何も変更しない
	// 変わりに新しいPointオブジェクトを返す
	
	var p = new Point(0, 1);
	var newP = p.withX(1000);
	log("newP x <- 1000", newP); // => {_x: 1000, _y: 1}
	log("p", p); // => {_x: 0, _y: 1} // もとのオブジェクトは変更されていない
	
	// 不変オブジェクトに対する変更操作は全て新しいオブジェクトを返すべきである
	// 副作用として良いチェーンAPIを使うことができる
	
	var p = (new Point(0,1)).withX(100).withY(-100);
	log("p", p); // => {_x: 100, _y: -100}
	
	// ・不変オブジェクトは生成時の値を保持し、決して変更するべきではない
	// ・不変オブジェクトに対する操作はその結果として新しいオブジェクトを返す
	// (大きなデータ構造をまるまるコピーすることを避けるために、インスタンス間である程度の要素を共有するような
	// 不変オブジェクトを生成する方法もある)
	
	// これらのルールを守ったとしても、問題に突き当たることもある
	// e.g. 生成時に要素の配列をとり、(部分的な)キューに入れるロジックを提供する
	//      Queueというデータ型の実装を考える
	function Queue(elems) {
		this._q = elems;
	}
	
	Queue.prototype = {
		enqueue: function(thing) {
			return new Queue(cat(this._q, [thing]));
		}
	};
	// Pointと同様にQueueオブジェクトは生成時にシード値をとる
	// インスタンスのシード値に新しい要素を加えるenqueueメソッドを提供する
	// cat関数は不変性を損なわないので、Queueインスタンス間で参照を共有するような問題を排除する
	var seed = [1, 2, 3];
	var q = new Queue(seed);
	log("q", q); // => {_q: [1, 2, 3]}
	
	var q2 = q.enqueue(108);
	log("q2", q2); // => {_q: [1, 2, 3, 108]}
	log("q", q); // => {_q: [1, 2, 3]} // q2の生成後もqの値はそのままのこる
	
	// しかしシード値そのものに変更が加わると
	seed.push(10000);
	log("q", q); // => {_q: [1, 2, 3, 1000]}
	
	// 配列の参照elemsを直接使ってしまったことが問題
	// この問題を解決する新しいコンストラクタSaferQueueを実装する
	var SaferQueue = function(elems) {
		this._q = _.clone(elems);
	}
	
	SaferQueue.prototype = {
		enqueue: function(thing) {
			return new SaferQueue(cat(this._q, [thing]));
		}
	};
	// この場合「深い」コピーは不必要。なぜなQueueインスタンスの目的は要素の出し入れを行うことで
	// 複雑なデータ構造の操作を行うことではないから
	// 要素オブジェクト自体の不変性はQueueオブジェクトの責任外
	var seed = [1, 2, 3];
	var sq = new SaferQueue(seed);
	
	var sq2 = sq.enqueue(36);
	log("sq2", sq2); // => {_q: [1, 2, 3, 36]}
	
	seed.push(1000);
	log("sq", sq); // => {_q: [1, 2, 3]} // インスタンスは変更されない
	
	// 直接 _q が変更される危険性は残る
	// SaferQueue.prototypeのメソッドも、簡単に他の好きなメソッドに置き換えることができる
	
	// 安全性の確保の責任はすべて開発者に委ねられる
	
	//******************************************************************************************
	// p216 7.3.6 オブジェクト操作は往々にして低レイヤー操作
	
	// new 演算子やオブジェクトメソッドを使用することにより突然現れる問題がある
	var sq = SaferQueue([1, 2, 3]);
	// var sq2 = sq.enqueue(32); // 未定義またはNULL参照のプロパティenqueueは取得できません
	
	// インスタンス生成時にnewの付与を忘れてしまった
	// 次のようなコンストラクタを提供
	function queue() {
		return new SaferQueue(_.toArray(arguments));
	}
	
	var q = queue(1,2,3);
	
	// もう一歩進めてinvoker関数を使ってenqueueを委譲する関数を生成する
	var enqueue = invoker("enqueue", SaferQueue.prototype.enqueue);
	var sq2 = enqueue(q, 42);
	log("sq2", sq2); // => {_q: [1, 2, 3, 42]}
	
	// メソッドを直接呼び出す代わりに関数として使うことで柔軟性が手に入る
	// ・実際のデータ型をあまり心配する必要がない
	// ・ユースケースに対応した型のデータを返すことが出来る。
	//   e.g. 小さな配列は小さなマップをモデリングする場合には高速に動作するが
	//        マップが大きくなるとオブジェクトの方が適切な場合も発生する
	//        プログラムによってこの切り替えを透過的に行うことが出来る
	// ・データ型やメソッドが変更された場合、それを使用しているすべての場所を変更せず
	//   関数を変更するだけですむ
	// ・事前条件や事後条件を関数に与えることができる
	// ・関数合成が可能
	
	// このようにメソッドを使用することは、オブジェクト指向プログラミングの否定ではなく
	// 補完関係にある
	
	// 関数型スタイルでは、どのような型のデータが流れているかということよりも、関数の動作に注目する
	
	//******************************************************************************************
	// p218 7.4 変更コントロールのポリシー *****************************************************
	
	// 何らかの状態を変更することが必要な時が絶対にある
	// そのような変更を出来る限り少なくするための方法を考える
	
	// e.g.
	// プログラムの生存期間中にオブジェクトが生成され、そして変更される場所の依存関係をグラフで表した
	// 小さなプログラムを想像する
	
	//               moduleA                 
	//     yを変更                           
	// [x] -----------------------> [b]      
	//  |      |                     ^       
	//  |      v                     |       
	//  |     [y]---------->[a]-------       
	//  |                    |               
	//=======================================
	//  |     moduleB  ||    |  moduleC      
	//  v              ||    |               
	// [z]----->[f]----||-->[x]              
	//                 ||                    
	//                 ||                    
	// graph) 変更の網が存在するとどのような変更であってもグローバルに影響する可能性を持つ
	
	//               moduleA                 
	//                                       
	// [x]                                   
	//                                       
	//                                       
	//                                       
	//                                       
	//=======================================
	//        moduleB  ||       moduleC      
	//                 ||                    
	//                 ||                    
	//                 ||                    
	//                 ||                    
	// graph) もし変更を管理する絶対的な必要がある場合は、それを１箇所に分離しておくことが理想
	
	// 変更箇所を分離して一つにすることと、複雑さの低減と状態維持との間にある妥協点にたどり着くための戦略
	
	// 変更の範囲をコントロールする方法は、変更するものを分離しておくこと
	// つまり、任意のオブジェクトをその場で勝手に変更するのではなく、オブジェクトをあらかじめ
	// コンテナに格納しておいて、それを変更すること
	
	// var container = contain({name: "Lemonjon"});
	// container.set({name: "Lemongrab"});
	
	// と言う手法と以下の手法との比較となる
	
	// var being = {name: "Lemonjon"}
	// being.name = "Lemongrab";
	
	// このような考え方を一歩進めて、変数の変更は関数呼び出しの結果として発生するように制限できる
	
	// var container = contain({name: "Lemonjon"});
	// container.update(merge, {name: "Lemongrab"});
	
	// この考え方には二つの効果がある
	// 1つ目は、container#setメソッドのように値を直接書き換えるのではなく、コンテナの現在値といくつかの
	// 引数を渡された関数呼び出しの結果によって変更が起きるようになった
	// 2つ目は、この間接処理を関数レベルで行うことにより、ドメイン特化された制約チェック関数を含めて
	// 考えられる全ての関数によって値の変更が出来るようになった
	
	// オブジェクトがその場で変更され、それがプログラムの様々な場所で発生していたとすると
	// 値の制約チェックを行うことがどれだけ難しいか
	
	// コンテナ型のシンプルな実装
	
	function Container(init) {
		this._value = init;
	};
	
	var aNumber = new Container(42);
	log("aNumber", aNumber); // =>  {_value: 42}
	
	// updateメソッドの実装
	Container.prototype = {
		update: function(fun /*, args */) {
			var args = _.rest(arguments);
			var oldValue = this._value;
			this._value = fun.apply(this, construct(oldValue, args));
			return this._value;
		}
	};
	
	var aNumber = new Container(42);
	aNumber.update(function(n){ return n + 1});
	log("updated aNumber", aNumber); // =>  {_value: 43}
	
	// 複数の引数を渡す例
	aNumber.update(function(n, x, y, z) { return n / x / y / z}, 1, 2, 3);
	log("updated aNumber", aNumber); // =>  {_value: 7.166666666666667}
	
	// 制約関数を使った例
	
	// aNumber.update(_.compose(megaCheckedSqr, always(0)));
	// log("updated aNumber", aNumber); // =>  Erro: 0ではいけません

	aNumber.update(_.compose(megaCheckedSqr, always(2)));
	log("updated aNumber", aNumber); // =>  {_value: 4}
	
	
	//******************************************************************************************
	// p221 7.5 まとめ *************************************************************************
	
	// 純粋関数とは、関数自身がコントロールできる範囲外にあるどの変数も変更せず、返さず、そして
	// 依存することのない関数である。
	// 内部変数を変更する必要がある場合でも外部にその変更が気付かれな場合は大丈夫
	
	// プログラム内の特定の変更パターンに注意することによって、限りなく不変に近付けることができる
});